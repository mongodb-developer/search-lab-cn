"use strict";(self.webpackChunksearch_party_lab=self.webpackChunksearch_party_lab||[]).push([[5372],{2027:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>i});var o=n(5893),s=n(1151);const r={},a="\ud83d\udcd8 Mixing and matching",c={id:"search-operators/mix-and-match",title:"\ud83d\udcd8 Mixing and matching",description:"The whole value of using these operators comes from combining them to create search results that are more relevant to your users.",source:"@site/docs/5-search-operators/08-mix-and-match.mdx",sourceDirName:"5-search-operators",slug:"/search-operators/mix-and-match",permalink:"/search-lab-cn/docs/search-operators/mix-and-match",draft:!1,unlisted:!1,editUrl:"https://github.com/mongodb-developer/search-lab-cn/blob/main/docs/5-search-operators/08-mix-and-match.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udcd8 Score modifiers",permalink:"/search-lab-cn/docs/search-operators/score-modifier"},next:{title:"\ud83d\udc50 Exercises",permalink:"/search-lab-cn/docs/search-operators/exercises"}},h={},i=[{value:"Compound with scoring",id:"compound-with-scoring",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"-mixing-and-matching",children:"\ud83d\udcd8 Mixing and matching"}),"\n",(0,o.jsx)(t.p,{children:"The whole value of using these operators comes from combining them to create search results that are more relevant to your users."}),"\n",(0,o.jsxs)(t.p,{children:["Using the ",(0,o.jsx)(t.code,{children:"compound"})," operator, you can mix and match some of the operators you've just seen. The syntax for the ",(0,o.jsx)(t.code,{children:"compound"})," operator is:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'{\n  $search: {\n    "index": <index name>, // optional, defaults to "default"\n    "compound": {\n      <must | mustNot | should | filter>: [ { <clauses> } ],\n      "score": <options>\n    }\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"must"}),"\nClauses that must match to for a document to be included in the results. The returned score is the sum of the scores of all the subqueries in the clause."]}),"\n",(0,o.jsx)(t.p,{children:"Maps to the AND boolean operator."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"mustNot"}),"\nClauses that must not match for a document to be included in the results. mustNot clauses don't contribute to a returned document's score."]}),"\n",(0,o.jsx)(t.p,{children:"Maps to the AND NOT boolean operator."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"should"}),"\nClauses that you prefer to match in documents that are included in the results. Documents that contain a match for a should clause have higher scores than documents that don't contain a should clause. The returned score is the sum of the scores of all the subqueries in the clause."]}),"\n",(0,o.jsx)(t.p,{children:'Say you wanted to search for a book that contains "cats" in the title, but you prefer having shorter books, you can use the following query:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'{\n  $search: {\n    "index": "fulltextsearch",\n    "compound": {\n      "must": [\n        {\n          "text": {\n            "query": "cats",\n            "path": "title"\n          }\n        }\n      ],\n      "should": [\n        {\n          "range": {\n            "path": "pages",\n            "gt": 0,\n            "lt": 100\n          }\n        }\n      ]\n    }\n  }\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:'This will return all books that contain "cats" in the title, but will prefer shorter books. It will still return longer books, but they will be scored lower than shorter books.'}),"\n",(0,o.jsx)(t.h2,{id:"compound-with-scoring",children:"Compound with scoring"}),"\n",(0,o.jsxs)(t.p,{children:["You can also use the ",(0,o.jsx)(t.code,{children:"compound"})," operator with the ",(0,o.jsx)(t.code,{children:"score"}),' option to control how the scores of the subqueries are combined. Say the library has a monthly theme, and they want to promote the books that have a specific word in the synopsis. This month, the theme is "bears". Try to write a search query that will return the books a user queried for, but those who contain the word "bear" in it will have a higher score and come at the top. Try to have a book about Winnie the Pooh come first when a user searches for "honey".']}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Click here to see the answer"}),(0,o.jsx)("div",{children:(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'{\n    "index": "fulltextsearch",\n    "compound": {\n      "must": [\n        {\n          "text": {\n            "query": "honey",\n            "path": ["title", "author.name", "synopsis"]\n          }\n        }\n      ],\n      "should": [\n        {\n          "text": {\n            "query": "bear",\n            "path": "synopsis",\n            "score": {\n              "boost": { value: 10 }\n\t\t\t\t\t\t}\n          }\n        }\n      ]\n    }\n  }\n'})})})]})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>a});var o=n(7294);const s={},r=o.createContext(s);function a(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);